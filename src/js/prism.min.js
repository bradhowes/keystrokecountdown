/* PrismJS 1.12.2
 http://prismjs.com/download.html#themes=prism-twilight&languages=markup+css+clike+javascript+c+aspnet+autohotkey+bash+cpp+csharp+diff+docker+git+go+handlebars+java+json+makefile+markdown+nasm+nginx+objectivec+sql+powershell+protobuf+python+r+typescript+scala+scheme+swift+yaml&plugins=command-line+keep-markup */
var _self = (typeof window !== 'undefined')
	? window   // if in browser
	: (
	    (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
		? self // if in worker
		: {}   // if in node js
	);

/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 * MIT license http://www.opensource.org/licenses/mit-license.php/
 * @author Lea Verou http://lea.verou.me
 */

var Prism = (function(){

    // Private helper vars
    var lang = /\blang(?:uage)?-(\w+)\b/i;
    var uniqueId = 0;

    var _ = _self.Prism = {
	manual: _self.Prism && _self.Prism.manual,
	disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
	util: {
	    encode: function (tokens) {
		if (tokens instanceof Token) {
		    return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
		} else if (_.util.type(tokens) === 'Array') {
		    return tokens.map(_.util.encode);
		} else {
		    return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
		}
	    },

	    type: function (o) {
		return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
	    },

	    objId: function (obj) {
		if (!obj['__id']) {
		    Object.defineProperty(obj, '__id', { value: ++uniqueId });
		}
		return obj['__id'];
	    },

	    // Deep clone a language definition (e.g. to extend it)
	    clone: function (o, visited) {
		var type = _.util.type(o);
		visited = visited || {};

		switch (type) {
		case 'Object':
		    if (visited[_.util.objId(o)]) {
			return visited[_.util.objId(o)];
		    }
		    var clone = {};
		    visited[_.util.objId(o)] = clone;

		    for (var key in o) {
			if (o.hasOwnProperty(key)) {
			    clone[key] = _.util.clone(o[key], visited);
			}
		    }

		    return clone;

		case 'Array':
		    if (visited[_.util.objId(o)]) {
			return visited[_.util.objId(o)];
		    }
		    var clone = [];
		    visited[_.util.objId(o)] = clone;

		    o.forEach(function (v, i) {
			clone[i] = _.util.clone(v, visited);
		    });

		    return clone;
		}

		return o;
	    }
	},

	languages: {
	    extend: function (id, redef) {
		var lang = _.util.clone(_.languages[id]);

		for (var key in redef) {
		    lang[key] = redef[key];
		}

		return lang;
	    },

	    /**
	     * Insert a token before another token in a language literal
	     * As this needs to recreate the object (we cannot actually insert before keys in object literals),
	     * we cannot just provide an object, we need anobject and a key.
	     * @param inside The key (or language id) of the parent
	     * @param before The key to insert before. If not provided, the function appends instead.
	     * @param insert Object with the key/value pairs to insert
	     * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
	     */
	    insertBefore: function (inside, before, insert, root) {
		root = root || _.languages;
		var grammar = root[inside];

		if (arguments.length == 2) {
		    insert = arguments[1];

		    for (var newToken in insert) {
			if (insert.hasOwnProperty(newToken)) {
			    grammar[newToken] = insert[newToken];
			}
		    }

		    return grammar;
		}

		var ret = {};

		for (var token in grammar) {

		    if (grammar.hasOwnProperty(token)) {

			if (token == before) {

			    for (var newToken in insert) {

				if (insert.hasOwnProperty(newToken)) {
				    ret[newToken] = insert[newToken];
				}
			    }
			}

			ret[token] = grammar[token];
		    }
		}

		// Update references in other language definitions
		_.languages.DFS(_.languages, function(key, value) {
		    if (value === root[inside] && key != inside) {
			this[key] = ret;
		    }
		});

		return root[inside] = ret;
	    },

	    // Traverse a language definition with Depth First Search
	    DFS: function(o, callback, type, visited) {
		visited = visited || {};
		for (var i in o) {
		    if (o.hasOwnProperty(i)) {
			callback.call(o, i, o[i], type || i);

			if (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {
			    visited[_.util.objId(o[i])] = true;
			    _.languages.DFS(o[i], callback, null, visited);
			}
			else if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {
			    visited[_.util.objId(o[i])] = true;
			    _.languages.DFS(o[i], callback, i, visited);
			}
		    }
		}
	    }
	},
	plugins: {},

	highlightAll: function(async, callback) {
	    _.highlightAllUnder(document, async, callback);
	},

	highlightAllUnder: function(container, async, callback) {
	    var env = {
		callback: callback,
		selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
	    };

	    _.hooks.run("before-highlightall", env);

	    var elements = env.elements || container.querySelectorAll(env.selector);

	    for (var i=0, element; element = elements[i++];) {
		_.highlightElement(element, async === true, env.callback);
	    }
	},

	highlightElement: function(element, async, callback) {
	    // Find language
	    var language, grammar, parent = element;

	    while (parent && !lang.test(parent.className)) {
		parent = parent.parentNode;
	    }

	    if (parent) {
		language = (parent.className.match(lang) || [,''])[1].toLowerCase();
		grammar = _.languages[language];
	    }

	    // Set language on the element, if not present
	    element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;

	    if (element.parentNode) {
		// Set language on the parent, for styling
		parent = element.parentNode;

		if (/pre/i.test(parent.nodeName)) {
		    parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
		}
	    }

	    var code = element.textContent;

	    var env = {
		element: element,
		language: language,
		grammar: grammar,
		code: code
	    };

	    _.hooks.run('before-sanity-check', env);

	    if (!env.code || !env.grammar) {
		if (env.code) {
		    _.hooks.run('before-highlight', env);
		    env.element.textContent = env.code;
		    _.hooks.run('after-highlight', env);
		}
		_.hooks.run('complete', env);
		return;
	    }

	    _.hooks.run('before-highlight', env);

	    if (async && _self.Worker) {
		var worker = new Worker(_.filename);

		worker.onmessage = function(evt) {
		    env.highlightedCode = evt.data;

		    _.hooks.run('before-insert', env);

		    env.element.innerHTML = env.highlightedCode;

		    callback && callback.call(env.element);
		    _.hooks.run('after-highlight', env);
		    _.hooks.run('complete', env);
		};

		worker.postMessage(JSON.stringify({
		    language: env.language,
		    code: env.code,
		    immediateClose: true
		}));
	    }
	    else {
		env.highlightedCode = _.highlight(env.code, env.grammar, env.language);

		_.hooks.run('before-insert', env);

		env.element.innerHTML = env.highlightedCode;

		callback && callback.call(element);

		_.hooks.run('after-highlight', env);
		_.hooks.run('complete', env);
	    }
	},

	highlight: function (text, grammar, language) {
	    var tokens = _.tokenize(text, grammar);
	    return Token.stringify(_.util.encode(tokens), language);
	},

	matchGrammar: function (text, strarr, grammar, index, startPos, oneshot, target) {
	    var Token = _.Token;

	    for (var token in grammar) {
		if(!grammar.hasOwnProperty(token) || !grammar[token]) {
		    continue;
		}

		if (token == target) {
		    return;
		}

		var patterns = grammar[token];
		patterns = (_.util.type(patterns) === "Array") ? patterns : [patterns];

		for (var j = 0; j < patterns.length; ++j) {
		    var pattern = patterns[j],
			inside = pattern.inside,
			lookbehind = !!pattern.lookbehind,
			greedy = !!pattern.greedy,
			lookbehindLength = 0,
			alias = pattern.alias;

		    if (greedy && !pattern.pattern.global) {
			// Without the global flag, lastIndex won't work
			var flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
			pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
		    }

		    pattern = pattern.pattern || pattern;

		    // Don’t cache length as it changes during the loop
		    for (var i = index, pos = startPos; i < strarr.length; pos += strarr[i].length, ++i) {

			var str = strarr[i];

			if (strarr.length > text.length) {
			    // Something went terribly wrong, ABORT, ABORT!
			    return;
			}

			if (str instanceof Token) {
			    continue;
			}

			pattern.lastIndex = 0;

			var match = pattern.exec(str),
			    delNum = 1;

			// Greedy patterns can override/remove up to two previously matched tokens
			if (!match && greedy && i != strarr.length - 1) {
			    pattern.lastIndex = pos;
			    match = pattern.exec(text);
			    if (!match) {
				break;
			    }

			    var from = match.index + (lookbehind ? match[1].length : 0),
				to = match.index + match[0].length,
				k = i,
				p = pos;

			    for (var len = strarr.length; k < len && (p < to || (!strarr[k].type && !strarr[k - 1].greedy)); ++k) {
				p += strarr[k].length;
				// Move the index i to the element in strarr that is closest to from
				if (from >= p) {
				    ++i;
				    pos = p;
				}
			    }

			    /*
			     * If strarr[i] is a Token, then the match starts inside another Token, which is invalid
			     * If strarr[k - 1] is greedy we are in conflict with another greedy pattern
			     */
			    if (strarr[i] instanceof Token || strarr[k - 1].greedy) {
				continue;
			    }

			    // Number of tokens to delete and replace with the new match
			    delNum = k - i;
			    str = text.slice(pos, p);
			    match.index -= pos;
			}

			if (!match) {
			    if (oneshot) {
				break;
			    }

			    continue;
			}

			if(lookbehind) {
			    lookbehindLength = match[1] ? match[1].length : 0;
			}

			var from = match.index + lookbehindLength,
			    match = match[0].slice(lookbehindLength),
			    to = from + match.length,
			    before = str.slice(0, from),
			    after = str.slice(to);

			var args = [i, delNum];

			if (before) {
			    ++i;
			    pos += before.length;
			    args.push(before);
			}

			var wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);

			args.push(wrapped);

			if (after) {
			    args.push(after);
			}

			Array.prototype.splice.apply(strarr, args);

			if (delNum != 1)
			    _.matchGrammar(text, strarr, grammar, i, pos, true, token);

			if (oneshot)
			    break;
		    }
		}
	    }
	},

	tokenize: function(text, grammar, language) {
	    var strarr = [text];

	    var rest = grammar.rest;

	    if (rest) {
		for (var token in rest) {
		    grammar[token] = rest[token];
		}

		delete grammar.rest;
	    }

	    _.matchGrammar(text, strarr, grammar, 0, 0, false);

	    return strarr;
	},

	hooks: {
	    all: {},

	    add: function (name, callback) {
		var hooks = _.hooks.all;

		hooks[name] = hooks[name] || [];

		hooks[name].push(callback);
	    },

	    run: function (name, env) {
		var callbacks = _.hooks.all[name];

		if (!callbacks || !callbacks.length) {
		    return;
		}

		for (var i=0, callback; callback = callbacks[i++];) {
		    callback(env);
		}
	    }
	}
    };

    var Token = _.Token = function(type, content, alias, matchedStr, greedy) {
	this.type = type;
	this.content = content;
	this.alias = alias;
	// Copy of the full string this token was created from
	this.length = (matchedStr || "").length|0;
	this.greedy = !!greedy;
    };

    Token.stringify = function(o, language, parent) {
	if (typeof o == 'string') {
	    return o;
	}

	if (_.util.type(o) === 'Array') {
	    return o.map(function(element) {
		return Token.stringify(element, language, o);
	    }).join('');
	}

	var env = {
	    type: o.type,
	    content: Token.stringify(o.content, language, parent),
	    tag: 'span',
	    classes: ['token', o.type],
	    attributes: {},
	    language: language,
	    parent: parent
	};

	if (o.alias) {
	    var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];
	    Array.prototype.push.apply(env.classes, aliases);
	}

	_.hooks.run('wrap', env);

	var attributes = Object.keys(env.attributes).map(function(name) {
	    return name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
	}).join(' ');

	return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';

    };

    if (!_self.document) {
	if (!_self.addEventListener) {
	    // in Node.js
	    return _self.Prism;
	}

	if (!_.disableWorkerMessageHandler) {
	    // In worker
	    _self.addEventListener('message', function (evt) {
		var message = JSON.parse(evt.data),
		    lang = message.language,
		    code = message.code,
		    immediateClose = message.immediateClose;

		_self.postMessage(_.highlight(code, _.languages[lang], lang));
		if (immediateClose) {
		    _self.close();
		}
	    }, false);
	}

	return _self.Prism;
    }

    //Get current script and highlight
    var script = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop();

    if (script) {
	_.filename = script.src;

	if (!_.manual && !script.hasAttribute('data-manual')) {
	    if(document.readyState !== "loading") {
		if (window.requestAnimationFrame) {
		    window.requestAnimationFrame(_.highlightAll);
		} else {
		    window.setTimeout(_.highlightAll, 16);
		}
	    }
	    else {
		document.addEventListener('DOMContentLoaded', _.highlightAll);
	    }
	}
    }

    return _self.Prism;

})();

if (typeof module !== 'undefined' && module.exports) {
    module.exports = Prism;
}

// hack for components to work correctly in node.js
if (typeof global !== 'undefined') {
    global.Prism = Prism;
}
;
Prism.languages.markup = {
    'comment': /<!--[\s\S]*?-->/,
    'prolog': /<\?[\s\S]+?\?>/,
    'doctype': /<!DOCTYPE[\s\S]+?>/i,
    'cdata': /<!\[CDATA\[[\s\S]*?]]>/i,
    'tag': {
	pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i,
	greedy: true,
	inside: {
	    'tag': {
		pattern: /^<\/?[^\s>\/]+/i,
		inside: {
		    'punctuation': /^<\/?/,
		    'namespace': /^[^\s>\/:]+:/
		}
	    },
	    'attr-value': {
		pattern: /=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/i,
		inside: {
		    'punctuation': [
			    /^=/,
			{
			    pattern: /(^|[^\\])["']/,
			    lookbehind: true
			}
		    ]
		}
	    },
	    'punctuation': /\/?>/,
	    'attr-name': {
		pattern: /[^\s>\/]+/,
		inside: {
		    'namespace': /^[^\s>\/:]+:/
		}
	    }

	}
    },
    'entity': /&#?[\da-z]{1,8};/i
};

Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
    Prism.languages.markup['entity'];

// Plugin to make entity title show the real entity, idea by Roman Komarov
Prism.hooks.add('wrap', function(env) {

    if (env.type === 'entity') {
	env.attributes['title'] = env.content.replace(/&amp;/, '&');
    }
});

Prism.languages.xml = Prism.languages.markup;
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;

Prism.languages.css = {
    'comment': /\/\*[\s\S]*?\*\//,
    'atrule': {
	pattern: /@[\w-]+?.*?(?:;|(?=\s*\{))/i,
	inside: {
	    'rule': /@[\w-]+/
	    // See rest below
	}
    },
    'url': /url\((?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
    'selector': /[^{}\s][^{};]*?(?=\s*\{)/,
    'string': {
	pattern: /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
	greedy: true
    },
    'property': /[-_a-z\xA0-\uFFFF][-\w\xA0-\uFFFF]*(?=\s*:)/i,
    'important': /\B!important\b/i,
    'function': /[-a-z0-9]+(?=\()/i,
    'punctuation': /[(){};:]/
};

Prism.languages.css['atrule'].inside.rest = Prism.languages.css;

if (Prism.languages.markup) {
    Prism.languages.insertBefore('markup', 'tag', {
	'style': {
	    pattern: /(<style[\s\S]*?>)[\s\S]*?(?=<\/style>)/i,
	    lookbehind: true,
	    inside: Prism.languages.css,
	    alias: 'language-css',
	    greedy: true
	}
    });

    Prism.languages.insertBefore('inside', 'attr-value', {
	'style-attr': {
	    pattern: /\s*style=("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/i,
	    inside: {
		'attr-name': {
		    pattern: /^\s*style/i,
		    inside: Prism.languages.markup.tag.inside
		},
		'punctuation': /^\s*=\s*['"]|['"]\s*$/,
		'attr-value': {
		    pattern: /.+/i,
		    inside: Prism.languages.css
		}
	    },
	    alias: 'language-css'
	}
    }, Prism.languages.markup.tag);
};
Prism.languages.clike = {
    'comment': [
	{
	    pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
	    lookbehind: true
	},
	{
	    pattern: /(^|[^\\:])\/\/.*/,
	    lookbehind: true
	}
    ],
    'string': {
	pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
	greedy: true
    },
    'class-name': {
	pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,
	lookbehind: true,
	inside: {
	    punctuation: /[.\\]/
	}
    },
    'keyword': /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
    'boolean': /\b(?:true|false)\b/,
    'function': /[a-z0-9_]+(?=\()/i,
    'number': /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,
    'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
    'punctuation': /[{}[\];(),.:]/
};

Prism.languages.javascript = Prism.languages.extend('clike', {
    'keyword': /\b(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,
    'number': /\b(?:0[xX][\dA-Fa-f]+|0[bB][01]+|0[oO][0-7]+|NaN|Infinity)\b|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee][+-]?\d+)?/,
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    'function': /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*\()/i,
    'operator': /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/
});

Prism.languages.insertBefore('javascript', 'keyword', {
    'regex': {
	pattern: /(^|[^/])\/(?!\/)(\[[^\]\r\n]+]|\\.|[^/\\\[\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,
	lookbehind: true,
	greedy: true
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    'function-variable': {
	pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=\s*(?:function\b|(?:\([^()]*\)|[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/i,
	alias: 'function'
    }
});

Prism.languages.insertBefore('javascript', 'string', {
    'template-string': {
	pattern: /`(?:\\[\s\S]|[^\\`])*`/,
	greedy: true,
	inside: {
	    'interpolation': {
		pattern: /\$\{[^}]+\}/,
		inside: {
		    'interpolation-punctuation': {
			pattern: /^\$\{|\}$/,
			alias: 'punctuation'
		    },
		    rest: Prism.languages.javascript
		}
	    },
	    'string': /[\s\S]+/
	}
    }
});

if (Prism.languages.markup) {
    Prism.languages.insertBefore('markup', 'tag', {
	'script': {
	    pattern: /(<script[\s\S]*?>)[\s\S]*?(?=<\/script>)/i,
	    lookbehind: true,
	    inside: Prism.languages.javascript,
	    alias: 'language-javascript',
	    greedy: true
	}
    });
}

Prism.languages.js = Prism.languages.javascript;

Prism.languages.c = Prism.languages.extend('clike', {
    'keyword': /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\b/,
    'operator': /-[>-]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/]/,
    'number': /(?:\b0x[\da-f]+|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?)[ful]*/i
});

Prism.languages.insertBefore('c', 'string', {
    'macro': {
	// allow for multiline macro definitions
	// spaces after the # character compile fine with gcc
	pattern: /(^\s*)#\s*[a-z]+(?:[^\r\n\\]|\\(?:\r\n|[\s\S]))*/im,
	lookbehind: true,
	alias: 'property',
	inside: {
	    // highlight the path of the include statement as a string
	    'string': {
		pattern: /(#\s*include\s*)(?:<.+?>|("|')(?:\\?.)+?\2)/,
		lookbehind: true
	    },
	    // highlight macro directives as keywords
	    'directive': {
		pattern: /(#\s*)\b(?:define|defined|elif|else|endif|error|ifdef|ifndef|if|import|include|line|pragma|undef|using)\b/,
		lookbehind: true,
		alias: 'keyword'
	    }
	}
    },
    // highlight predefined macros as constants
    'constant': /\b(?:__FILE__|__LINE__|__DATE__|__TIME__|__TIMESTAMP__|__func__|EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|stdin|stdout|stderr)\b/
});

delete Prism.languages.c['class-name'];
delete Prism.languages.c['boolean'];

Prism.languages.aspnet = Prism.languages.extend('markup', {
    'page-directive tag': {
	pattern: /<%\s*@.*%>/i,
	inside: {
	    'page-directive tag': /<%\s*@\s*(?:Assembly|Control|Implements|Import|Master(?:Type)?|OutputCache|Page|PreviousPageType|Reference|Register)?|%>/i,
	    rest: Prism.languages.markup.tag.inside
	}
    },
    'directive tag': {
	pattern: /<%.*%>/i,
	inside: {
	    'directive tag': /<%\s*?[$=%#:]{0,2}|%>/i,
	    rest: Prism.languages.csharp
	}
    }
});
// Regexp copied from prism-markup, with a negative look-ahead added
Prism.languages.aspnet.tag.pattern = /<(?!%)\/?[^\s>\/]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i;

// match directives of attribute value foo="<% Bar %>"
Prism.languages.insertBefore('inside', 'punctuation', {
    'directive tag': Prism.languages.aspnet['directive tag']
}, Prism.languages.aspnet.tag.inside["attr-value"]);

Prism.languages.insertBefore('aspnet', 'comment', {
    'asp comment': /<%--[\s\S]*?--%>/
});

// script runat="server" contains csharp, not javascript
Prism.languages.insertBefore('aspnet', Prism.languages.javascript ? 'script' : 'tag', {
    'asp script': {
	pattern: /(<script(?=.*runat=['"]?server['"]?)[\s\S]*?>)[\s\S]*?(?=<\/script>)/i,
	lookbehind: true,
	inside: Prism.languages.csharp || {}
    }
});
// NOTES - follows first-first highlight method, block is locked after highlight, different from SyntaxHl
Prism.languages.autohotkey= {
    'comment': {
	pattern: /(^[^";\n]*("[^"\n]*?"[^"\n]*?)*)(?:;.*$|^\s*\/\*[\s\S]*\n\*\/)/m,
	lookbehind: true
    },
    'string': /"(?:[^"\n\r]|"")*"/m,
    'function': /[^(); \t,\n+*\-=?>:\\\/<&%\[\]]+?(?=\()/m,  //function - don't use .*\) in the end bcoz string locks it
    'tag': /^[ \t]*[^\s:]+?(?=:(?:[^:]|$))/m,  //labels
    'variable': /%\w+%/,
    'number': /\b0x[\dA-Fa-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee]-?\d+)?/,
    'operator': /\?|\/\/?=?|:=|\|[=|]?|&[=&]?|\+[=+]?|-[=-]?|\*[=*]?|<(?:<=?|>|=)?|>>?=?|[.^!=~]=?|\b(?:AND|NOT|OR)\b/,
    'punctuation': /[{}[\]():,]/,
    'boolean': /\b(?:true|false)\b/,

    'selector': /\b(?:AutoTrim|BlockInput|Break|Click|ClipWait|Continue|Control|ControlClick|ControlFocus|ControlGet|ControlGetFocus|ControlGetPos|ControlGetText|ControlMove|ControlSend|ControlSendRaw|ControlSetText|CoordMode|Critical|DetectHiddenText|DetectHiddenWindows|Drive|DriveGet|DriveSpaceFree|EnvAdd|EnvDiv|EnvGet|EnvMult|EnvSet|EnvSub|EnvUpdate|Exit|ExitApp|FileAppend|FileCopy|FileCopyDir|FileCreateDir|FileCreateShortcut|FileDelete|FileEncoding|FileGetAttrib|FileGetShortcut|FileGetSize|FileGetTime|FileGetVersion|FileInstall|FileMove|FileMoveDir|FileRead|FileReadLine|FileRecycle|FileRecycleEmpty|FileRemoveDir|FileSelectFile|FileSelectFolder|FileSetAttrib|FileSetTime|FormatTime|GetKeyState|Gosub|Goto|GroupActivate|GroupAdd|GroupClose|GroupDeactivate|Gui|GuiControl|GuiControlGet|Hotkey|ImageSearch|IniDelete|IniRead|IniWrite|Input|InputBox|KeyWait|ListHotkeys|ListLines|ListVars|Loop|Menu|MouseClick|MouseClickDrag|MouseGetPos|MouseMove|MsgBox|OnExit|OutputDebug|Pause|PixelGetColor|PixelSearch|PostMessage|Process|Progress|Random|RegDelete|RegRead|RegWrite|Reload|Repeat|Return|Run|RunAs|RunWait|Send|SendEvent|SendInput|SendMessage|SendMode|SendPlay|SendRaw|SetBatchLines|SetCapslockState|SetControlDelay|SetDefaultMouseSpeed|SetEnv|SetFormat|SetKeyDelay|SetMouseDelay|SetNumlockState|SetScrollLockState|SetStoreCapslockMode|SetTimer|SetTitleMatchMode|SetWinDelay|SetWorkingDir|Shutdown|Sleep|Sort|SoundBeep|SoundGet|SoundGetWaveVolume|SoundPlay|SoundSet|SoundSetWaveVolume|SplashImage|SplashTextOff|SplashTextOn|SplitPath|StatusBarGetText|StatusBarWait|StringCaseSense|StringGetPos|StringLeft|StringLen|StringLower|StringMid|StringReplace|StringRight|StringSplit|StringTrimLeft|StringTrimRight|StringUpper|Suspend|SysGet|Thread|ToolTip|Transform|TrayTip|URLDownloadToFile|WinActivate|WinActivateBottom|WinClose|WinGet|WinGetActiveStats|WinGetActiveTitle|WinGetClass|WinGetPos|WinGetText|WinGetTitle|WinHide|WinKill|WinMaximize|WinMenuSelectItem|WinMinimize|WinMinimizeAll|WinMinimizeAllUndo|WinMove|WinRestore|WinSet|WinSetTitle|WinShow|WinWait|WinWaitActive|WinWaitClose|WinWaitNotActive)\b/i,

    'constant': /\b(?:a_ahkpath|a_ahkversion|a_appdata|a_appdatacommon|a_autotrim|a_batchlines|a_caretx|a_carety|a_computername|a_controldelay|a_cursor|a_dd|a_ddd|a_dddd|a_defaultmousespeed|a_desktop|a_desktopcommon|a_detecthiddentext|a_detecthiddenwindows|a_endchar|a_eventinfo|a_exitreason|a_formatfloat|a_formatinteger|a_gui|a_guievent|a_guicontrol|a_guicontrolevent|a_guiheight|a_guiwidth|a_guix|a_guiy|a_hour|a_iconfile|a_iconhidden|a_iconnumber|a_icontip|a_index|a_ipaddress1|a_ipaddress2|a_ipaddress3|a_ipaddress4|a_isadmin|a_iscompiled|a_iscritical|a_ispaused|a_issuspended|a_isunicode|a_keydelay|a_language|a_lasterror|a_linefile|a_linenumber|a_loopfield|a_loopfileattrib|a_loopfiledir|a_loopfileext|a_loopfilefullpath|a_loopfilelongpath|a_loopfilename|a_loopfileshortname|a_loopfileshortpath|a_loopfilesize|a_loopfilesizekb|a_loopfilesizemb|a_loopfiletimeaccessed|a_loopfiletimecreated|a_loopfiletimemodified|a_loopreadline|a_loopregkey|a_loopregname|a_loopregsubkey|a_loopregtimemodified|a_loopregtype|a_mday|a_min|a_mm|a_mmm|a_mmmm|a_mon|a_mousedelay|a_msec|a_mydocuments|a_now|a_nowutc|a_numbatchlines|a_ostype|a_osversion|a_priorhotkey|programfiles|a_programfiles|a_programs|a_programscommon|a_screenheight|a_screenwidth|a_scriptdir|a_scriptfullpath|a_scriptname|a_sec|a_space|a_startmenu|a_startmenucommon|a_startup|a_startupcommon|a_stringcasesense|a_tab|a_temp|a_thisfunc|a_thishotkey|a_thislabel|a_thismenu|a_thismenuitem|a_thismenuitempos|a_tickcount|a_timeidle|a_timeidlephysical|a_timesincepriorhotkey|a_timesincethishotkey|a_titlematchmode|a_titlematchmodespeed|a_username|a_wday|a_windelay|a_windir|a_workingdir|a_yday|a_year|a_yweek|a_yyyy|clipboard|clipboardall|comspec|errorlevel)\b/i,

    'builtin': /\b(?:abs|acos|asc|asin|atan|ceil|chr|class|cos|dllcall|exp|fileexist|Fileopen|floor|il_add|il_create|il_destroy|instr|substr|isfunc|islabel|IsObject|ln|log|lv_add|lv_delete|lv_deletecol|lv_getcount|lv_getnext|lv_gettext|lv_insert|lv_insertcol|lv_modify|lv_modifycol|lv_setimagelist|mod|onmessage|numget|numput|registercallback|regexmatch|regexreplace|round|sin|tan|sqrt|strlen|sb_seticon|sb_setparts|sb_settext|strsplit|tv_add|tv_delete|tv_getchild|tv_getcount|tv_getnext|tv_get|tv_getparent|tv_getprev|tv_getselection|tv_gettext|tv_modify|varsetcapacity|winactive|winexist|__New|__Call|__Get|__Set)\b/i,

    'symbol': /\b(?:alt|altdown|altup|appskey|backspace|browser_back|browser_favorites|browser_forward|browser_home|browser_refresh|browser_search|browser_stop|bs|capslock|ctrl|ctrlbreak|ctrldown|ctrlup|del|delete|down|end|enter|esc|escape|f1|f10|f11|f12|f13|f14|f15|f16|f17|f18|f19|f2|f20|f21|f22|f23|f24|f3|f4|f5|f6|f7|f8|f9|home|ins|insert|joy1|joy10|joy11|joy12|joy13|joy14|joy15|joy16|joy17|joy18|joy19|joy2|joy20|joy21|joy22|joy23|joy24|joy25|joy26|joy27|joy28|joy29|joy3|joy30|joy31|joy32|joy4|joy5|joy6|joy7|joy8|joy9|joyaxes|joybuttons|joyinfo|joyname|joypov|joyr|joyu|joyv|joyx|joyy|joyz|lalt|launch_app1|launch_app2|launch_mail|launch_media|lbutton|lcontrol|lctrl|left|lshift|lwin|lwindown|lwinup|mbutton|media_next|media_play_pause|media_prev|media_stop|numlock|numpad0|numpad1|numpad2|numpad3|numpad4|numpad5|numpad6|numpad7|numpad8|numpad9|numpadadd|numpadclear|numpaddel|numpaddiv|numpaddot|numpaddown|numpadend|numpadenter|numpadhome|numpadins|numpadleft|numpadmult|numpadpgdn|numpadpgup|numpadright|numpadsub|numpadup|pgdn|pgup|printscreen|ralt|rbutton|rcontrol|rctrl|right|rshift|rwin|rwindown|rwinup|scrolllock|shift|shiftdown|shiftup|space|tab|up|volume_down|volume_mute|volume_up|wheeldown|wheelleft|wheelright|wheelup|xbutton1|xbutton2)\b/i,

    'important': /#\b(?:AllowSameLineComments|ClipboardTimeout|CommentFlag|ErrorStdOut|EscapeChar|HotkeyInterval|HotkeyModifierTimeout|Hotstring|IfWinActive|IfWinExist|IfWinNotActive|IfWinNotExist|Include|IncludeAgain|InstallKeybdHook|InstallMouseHook|KeyHistory|LTrim|MaxHotkeysPerInterval|MaxMem|MaxThreads|MaxThreadsBuffer|MaxThreadsPerHotkey|NoEnv|NoTrayIcon|Persistent|SingleInstance|UseHook|WinActivateForce)\b/i,

    'keyword': /\b(?:Abort|AboveNormal|Add|ahk_class|ahk_group|ahk_id|ahk_pid|All|Alnum|Alpha|AltSubmit|AltTab|AltTabAndMenu|AltTabMenu|AltTabMenuDismiss|AlwaysOnTop|AutoSize|Background|BackgroundTrans|BelowNormal|between|BitAnd|BitNot|BitOr|BitShiftLeft|BitShiftRight|BitXOr|Bold|Border|Button|ByRef|Checkbox|Checked|CheckedGray|Choose|ChooseString|Close|Color|ComboBox|Contains|ControlList|Count|Date|DateTime|Days|DDL|Default|DeleteAll|Delimiter|Deref|Destroy|Digit|Disable|Disabled|DropDownList|Edit|Eject|Else|Enable|Enabled|Error|Exist|Expand|ExStyle|FileSystem|First|Flash|Float|FloatFast|Focus|Font|for|global|Grid|Group|GroupBox|GuiClose|GuiContextMenu|GuiDropFiles|GuiEscape|GuiSize|Hdr|Hidden|Hide|High|HKCC|HKCR|HKCU|HKEY_CLASSES_ROOT|HKEY_CURRENT_CONFIG|HKEY_CURRENT_USER|HKEY_LOCAL_MACHINE|HKEY_USERS|HKLM|HKU|Hours|HScroll|Icon|IconSmall|ID|IDLast|If|IfEqual|IfExist|IfGreater|IfGreaterOrEqual|IfInString|IfLess|IfLessOrEqual|IfMsgBox|IfNotEqual|IfNotExist|IfNotInString|IfWinActive|IfWinExist|IfWinNotActive|IfWinNotExist|Ignore|ImageList|in|Integer|IntegerFast|Interrupt|is|italic|Join|Label|LastFound|LastFoundExist|Limit|Lines|List|ListBox|ListView|local|Lock|Logoff|Low|Lower|Lowercase|MainWindow|Margin|Maximize|MaximizeBox|MaxSize|Minimize|MinimizeBox|MinMax|MinSize|Minutes|MonthCal|Mouse|Move|Multi|NA|No|NoActivate|NoDefault|NoHide|NoIcon|NoMainWindow|norm|Normal|NoSort|NoSortHdr|NoStandard|Not|NoTab|NoTimers|Number|Off|Ok|On|OwnDialogs|Owner|Parse|Password|Picture|Pixel|Pos|Pow|Priority|ProcessName|Radio|Range|Read|ReadOnly|Realtime|Redraw|REG_BINARY|REG_DWORD|REG_EXPAND_SZ|REG_MULTI_SZ|REG_SZ|Region|Relative|Rename|Report|Resize|Restore|Retry|RGB|Screen|Seconds|Section|Serial|SetLabel|ShiftAltTab|Show|Single|Slider|SortDesc|Standard|static|Status|StatusBar|StatusCD|strike|Style|Submit|SysMenu|Tab2|TabStop|Text|Theme|Tile|ToggleCheck|ToggleEnable|ToolWindow|Top|Topmost|TransColor|Transparent|Tray|TreeView|TryAgain|Type|UnCheck|underline|Unicode|Unlock|UpDown|Upper|Uppercase|UseErrorLevel|Vis|VisFirst|Visible|VScroll|Wait|WaitClose|WantCtrlA|WantF2|WantReturn|While|Wrap|Xdigit|xm|xp|xs|Yes|ym|yp|ys)\b/i
};
(function(Prism) {
    var insideString = {
	variable: [
	    // Arithmetic Environment
	    {
		pattern: /\$?\(\([\s\S]+?\)\)/,
		inside: {
		    // If there is a $ sign at the beginning highlight $(( and )) as variable
		    variable: [{
			pattern: /(^\$\(\([\s\S]+)\)\)/,
			lookbehind: true
		    },
			       /^\$\(\(/
			      ],
		    number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee]-?\d+)?/,
		    // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
		    operator: /--?|-=|\+\+?|\+=|!=?|~|\*\*?|\*=|\/=?|%=?|<<=?|>>=?|<=?|>=?|==?|&&?|&=|\^=?|\|\|?|\|=|\?|:/,
		    // If there is no $ sign at the beginning highlight (( and )) as punctuation
		    punctuation: /\(\(?|\)\)?|,|;/
		}
	    },
	    // Command Substitution
	    {
		pattern: /\$\([^)]+\)|`[^`]+`/,
		greedy: true,
		inside: {
		    variable: /^\$\(|^`|\)$|`$/
		}
	    },
		/\$(?:[\w#?*!@]+|\{[^}]+\})/i
	]
    };

    Prism.languages.bash = {
	'shebang': {
	    pattern: /^#!\s*\/bin\/bash|^#!\s*\/bin\/sh/,
	    alias: 'important'
	},
	'comment': {
	    pattern: /(^|[^"{\\])#.*/,
	    lookbehind: true
	},
	'string': [
	    //Support for Here-Documents https://en.wikipedia.org/wiki/Here_document
	    {
		pattern: /((?:^|[^<])<<\s*)["']?(\w+?)["']?\s*\r?\n(?:[\s\S])*?\r?\n\2/,
		lookbehind: true,
		greedy: true,
		inside: insideString
	    },
	    {
		pattern: /(["'])(?:\\[\s\S]|\$\([^)]+\)|`[^`]+`|(?!\1)[^\\])*\1/,
		greedy: true,
		inside: insideString
	    }
	],
	'variable': insideString.variable,
	// Originally based on http://ss64.com/bash/
	'function': {
	    pattern: /(^|[\s;|&])(?:alias|apropos|apt-get|aptitude|aspell|awk|basename|bash|bc|bg|builtin|bzip2|cal|cat|cd|cfdisk|chgrp|chmod|chown|chroot|chkconfig|cksum|clear|cmp|comm|command|cp|cron|crontab|csplit|cut|date|dc|dd|ddrescue|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|du|egrep|eject|enable|env|ethtool|eval|exec|expand|expect|export|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|getopts|git|grep|groupadd|groupdel|groupmod|groups|gzip|hash|head|help|hg|history|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|jobs|join|kill|killall|less|link|ln|locate|logname|logout|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|make|man|mkdir|mkfifo|mkisofs|mknod|more|most|mount|mtools|mtr|mv|mmv|nano|netstat|nice|nl|nohup|notify-send|npm|nslookup|open|op|passwd|paste|pathchk|ping|pkill|popd|pr|printcap|printenv|printf|ps|pushd|pv|pwd|quota|quotacheck|quotactl|ram|rar|rcp|read|readarray|readonly|reboot|rename|renice|remsync|rev|rm|rmdir|rsync|screen|scp|sdiff|sed|seq|service|sftp|shift|shopt|shutdown|sleep|slocate|sort|source|split|ssh|stat|strace|su|sudo|sum|suspend|sync|tail|tar|tee|test|time|timeout|times|touch|top|traceroute|trap|tr|tsort|tty|type|ulimit|umask|umount|unalias|uname|unexpand|uniq|units|unrar|unshar|uptime|useradd|userdel|usermod|users|uuencode|uudecode|v|vdir|vi|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yes|zip)(?=$|[\s;|&])/,
	    lookbehind: true
	},
	'keyword': {
	    pattern: /(^|[\s;|&])(?:let|:|\.|if|then|else|elif|fi|for|break|continue|while|in|case|function|select|do|done|until|echo|exit|return|set|declare)(?=$|[\s;|&])/,
	    lookbehind: true
	},
	'boolean': {
	    pattern: /(^|[\s;|&])(?:true|false)(?=$|[\s;|&])/,
	    lookbehind: true
	},
	'operator': /&&?|\|\|?|==?|!=?|<<<?|>>|<=?|>=?|=~/,
	'punctuation': /\$?\(\(?|\)\)?|\.\.|[{}[\];]/
    };

    var inside = insideString.variable[1].inside;
    inside.string = Prism.languages.bash.string;
    inside['function'] = Prism.languages.bash['function'];
    inside.keyword = Prism.languages.bash.keyword;
    inside.boolean = Prism.languages.bash.boolean;
    inside.operator = Prism.languages.bash.operator;
    inside.punctuation = Prism.languages.bash.punctuation;
    
    Prism.languages.shell = Prism.languages.bash;
})(Prism);

Prism.languages.cpp = Prism.languages.extend('c', {
    'keyword': /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|class|compl|const|constexpr|const_cast|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|float|for|friend|goto|if|inline|int|int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|long|mutable|namespace|new|noexcept|nullptr|operator|private|protected|public|register|reinterpret_cast|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/,
    'boolean': /\b(?:true|false)\b/,
    'operator': /--?|\+\+?|!=?|<{1,2}=?|>{1,2}=?|->|:{1,2}|={1,2}|\^|~|%|&{1,2}|\|\|?|\?|\*|\/|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/
});

Prism.languages.insertBefore('cpp', 'keyword', {
    'class-name': {
	pattern: /(class\s+)\w+/i,
	lookbehind: true
    }
});

Prism.languages.insertBefore('cpp', 'string', {
    'raw-string': {
	pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
	alias: 'string',
	greedy: true
    }
});

Prism.languages.csharp = Prism.languages.extend('clike', {
    'keyword': /\b(?:abstract|add|alias|as|ascending|async|await|base|bool|break|byte|case|catch|char|checked|class|const|continue|decimal|default|delegate|descending|do|double|dynamic|else|enum|event|explicit|extern|false|finally|fixed|float|for|foreach|from|get|global|goto|group|if|implicit|in|int|interface|internal|into|is|join|let|lock|long|namespace|new|null|object|operator|orderby|out|override|params|partial|private|protected|public|readonly|ref|remove|return|sbyte|sealed|select|set|short|sizeof|stackalloc|static|string|struct|switch|this|throw|true|try|typeof|uint|ulong|unchecked|unsafe|ushort|using|value|var|virtual|void|volatile|where|while|yield)\b/,
    'string': [
	{
	    pattern: /@("|')(?:\1\1|\\[\s\S]|(?!\1)[^\\])*\1/,
	    greedy: true
	},
	{
	    pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*?\1/,
	    greedy: true
	}
    ],
    'number': /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)f?/i
});

Prism.languages.insertBefore('csharp', 'keyword', {
    'generic-method': {
	pattern: /[a-z0-9_]+\s*<[^>\r\n]+?>\s*(?=\()/i,
	alias: 'function',
	inside: {
	    keyword: Prism.languages.csharp.keyword,
	    punctuation: /[<>(),.:]/
	}
    },
    'preprocessor': {
	pattern: /(^\s*)#.*/m,
	lookbehind: true,
	alias: 'property',
	inside: {
	    // highlight preprocessor directives as keywords
	    'directive': {
		pattern: /(\s*#)\b(?:define|elif|else|endif|endregion|error|if|line|pragma|region|undef|warning)\b/,
		lookbehind: true,
		alias: 'keyword'
	    }
	}
    }
});

Prism.languages.dotnet = Prism.languages.csharp;
Prism.languages.diff = {
    'coord': [
	// Match all kinds of coord lines (prefixed by "+++", "---" or "***").
	    /^(?:\*{3}|-{3}|\+{3}).*$/m,
	// Match "@@ ... @@" coord lines in unified diff.
	    /^@@.*@@$/m,
	// Match coord lines in normal diff (starts with a number).
	    /^\d+.*$/m
    ],

    // Match inserted and deleted lines. Support both +/- and >/< styles.
    'deleted': /^[-<].*$/m,
    'inserted': /^[+>].*$/m,

    // Match "different" lines (prefixed with "!") in context diff.
    'diff': {
	'pattern': /^!(?!!).+$/m,
	'alias': 'important'
    }
};

Prism.languages.docker = {
    'keyword': {
	pattern: /(^\s*)(?:ADD|ARG|CMD|COPY|ENTRYPOINT|ENV|EXPOSE|FROM|HEALTHCHECK|LABEL|MAINTAINER|ONBUILD|RUN|SHELL|STOPSIGNAL|USER|VOLUME|WORKDIR)(?=\s)/mi,
	lookbehind: true
    },
    'string': /("|')(?:(?!\1)[^\\\r\n]|\\(?:\r\n|[\s\S]))*\1/,
    'comment': /#.*/,
    'punctuation': /---|\.\.\.|[:[\]{}\-,|>?]/
};

Prism.languages.dockerfile = Prism.languages.docker;

Prism.languages.git = {
    /*
     * A simple one line comment like in a git status command
     * For instance:
     * $ git status
     * # On branch infinite-scroll
     * # Your branch and 'origin/sharedBranches/frontendTeam/infinite-scroll' have diverged,
     * # and have 1 and 2 different commits each, respectively.
     * nothing to commit (working directory clean)
     */
    'comment': /^#.*/m,

    /*
     * Regexp to match the changed lines in a git diff output. Check the example below.
     */
    'deleted': /^[-–].*/m,
    'inserted': /^\+.*/m,

    /*
     * a string (double and simple quote)
     */
    'string': /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/m,

    /*
     * a git command. It starts with a random prompt finishing by a $, then "git" then some other parameters
     * For instance:
     * $ git add file.txt
     */
    'command': {
	pattern: /^.*\$ git .*$/m,
	inside: {
	    /*
	     * A git command can contain a parameter starting by a single or a double dash followed by a string
	     * For instance:
	     * $ git diff --cached
	     * $ git log -p
	     */
	    'parameter': /\s--?\w+/m
	}
    },

    /*
     * Coordinates displayed in a git diff command
     * For instance:
     * $ git diff
     * diff --git file.txt file.txt
     * index 6214953..1d54a52 100644
     * --- file.txt
     * +++ file.txt
     * @@ -1 +1,2 @@
     * -Here's my tetx file
     * +Here's my text file
     * +And this is the second line
     */
    'coord': /^@@.*@@$/m,

    /*
     * Match a "commit [SHA1]" line in a git log output.
     * For instance:
     * $ git log
     * commit a11a14ef7e26f2ca62d4b35eac455ce636d0dc09
     * Author: lgiraudel
     * Date:   Mon Feb 17 11:18:34 2014 +0100
     *
     *     Add of a new line
     */
    'commit_sha1': /^commit \w{40}$/m
};

Prism.languages.go = Prism.languages.extend('clike', {
    'keyword': /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
    'builtin': /\b(?:bool|byte|complex(?:64|128)|error|float(?:32|64)|rune|string|u?int(?:8|16|32|64)?|uintptr|append|cap|close|complex|copy|delete|imag|len|make|new|panic|print(?:ln)?|real|recover)\b/,
    'boolean': /\b(?:_|iota|nil|true|false)\b/,
    'operator': /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
    'number': /(?:\b0x[a-f\d]+|(?:\b\d+\.?\d*|\B\.\d+)(?:e[-+]?\d+)?)i?/i,
    'string': {
	pattern: /(["'`])(\\[\s\S]|(?!\1)[^\\])*\1/,
	greedy: true
    }
});
delete Prism.languages.go['class-name'];

(function(Prism) {

    var handlebars_pattern = /\{\{\{[\s\S]+?\}\}\}|\{\{[\s\S]+?\}\}/;

    Prism.languages.handlebars = Prism.languages.extend('markup', {
	'handlebars': {
	    pattern: handlebars_pattern,
	    inside: {
		'delimiter': {
		    pattern: /^\{\{\{?|\}\}\}?$/i,
		    alias: 'punctuation'
		},
		'string': /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
		'number': /\b0x[\dA-Fa-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee][+-]?\d+)?/,
		'boolean': /\b(?:true|false)\b/,
		'block': {
		    pattern: /^(\s*~?\s*)[#\/]\S+?(?=\s*~?\s*$|\s)/i,
		    lookbehind: true,
		    alias: 'keyword'
		},
		'brackets': {
		    pattern: /\[[^\]]+\]/,
		    inside: {
			punctuation: /\[|\]/,
			variable: /[\s\S]+/
		    }
		},
		'punctuation': /[!"#%&'()*+,.\/;<=>@\[\\\]^`{|}~]/,
		'variable': /[^!"#%&'()*+,.\/;<=>@\[\\\]^`{|}~\s]+/
	    }
	}
    });

    // Comments are inserted at top so that they can
    // surround markup
    Prism.languages.insertBefore('handlebars', 'tag', {
	'handlebars-comment': {
	    pattern: /\{\{![\s\S]*?\}\}/,
	    alias: ['handlebars','comment']
	}
    });

    // Tokenize all inline Handlebars expressions that are wrapped in {{ }} or {{{ }}}
    // This allows for easy Handlebars + markup highlighting
    Prism.hooks.add('before-highlight', function(env) {
	if (env.language !== 'handlebars') {
	    return;
	}

	env.tokenStack = [];

	env.backupCode = env.code;
	env.code = env.code.replace(handlebars_pattern, function(match) {
	    var i = env.tokenStack.length;
	    // Check for existing strings
	    while (env.backupCode.indexOf('___HANDLEBARS' + i + '___') !== -1)
		++i;

	    // Create a sparse array
	    env.tokenStack[i] = match;

	    return '___HANDLEBARS' + i + '___';
	});
    });

    // Restore env.code for other plugins (e.g. line-numbers)
    Prism.hooks.add('before-insert', function(env) {
	if (env.language === 'handlebars') {
	    env.code = env.backupCode;
	    delete env.backupCode;
	}
    });

    // Re-insert the tokens after highlighting
    // and highlight them with defined grammar
    Prism.hooks.add('after-highlight', function(env) {
	if (env.language !== 'handlebars') {
	    return;
	}

	for (var i = 0, keys = Object.keys(env.tokenStack); i < keys.length; ++i) {
	    var k = keys[i];
	    var t = env.tokenStack[k];

	    // The replace prevents $$, $&, $`, $', $n, $nn from being interpreted as special patterns
	    env.highlightedCode = env.highlightedCode.replace('___HANDLEBARS' + k + '___', Prism.highlight(t, env.grammar, 'handlebars').replace(/\$/g, '$$$$'));
	}

	env.element.innerHTML = env.highlightedCode;
    });

}(Prism));

Prism.languages.java = Prism.languages.extend('clike', {
    'keyword': /\b(?:abstract|continue|for|new|switch|assert|default|goto|package|synchronized|boolean|do|if|private|this|break|double|implements|protected|throw|byte|else|import|public|throws|case|enum|instanceof|return|transient|catch|extends|int|short|try|char|final|interface|static|void|class|finally|long|strictfp|volatile|const|float|native|super|while)\b/,
    'number': /\b0b[01]+\b|\b0x[\da-f]*\.?[\da-fp-]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?[df]?/i,
    'operator': {
	pattern: /(^|[^.])(?:\+[+=]?|-[-=]?|!=?|<<?=?|>>?>?=?|==?|&[&=]?|\|[|=]?|\*=?|\/=?|%=?|\^=?|[?:~])/m,
	lookbehind: true
    }
});

Prism.languages.insertBefore('java','function', {
    'annotation': {
	alias: 'punctuation',
	pattern: /(^|[^.])@\w+/,
	lookbehind: true
    }
});

Prism.languages.json = {
    'property': /"(?:\\.|[^\\"\r\n])*"(?=\s*:)/i,
    'string': {
	pattern: /"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
	greedy: true
    },
    'number': /\b0x[\dA-Fa-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee][+-]?\d+)?/,
    'punctuation': /[{}[\]);,]/,
    'operator': /:/g,
    'boolean': /\b(?:true|false)\b/i,
    'null': /\bnull\b/i
};

Prism.languages.jsonp = Prism.languages.json;

Prism.languages.makefile = {
    'comment': {
	pattern: /(^|[^\\])#(?:\\(?:\r\n|[\s\S])|[^\\\r\n])*/,
	lookbehind: true
    },
    'string': {
	pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
	greedy: true
    },

    // Built-in target names
    'builtin': /\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,

    // Targets
    'symbol': {
	pattern: /^[^:=\r\n]+(?=\s*:(?!=))/m,
	inside: {
	    'variable': /\$+(?:[^(){}:#=\s]+|(?=[({]))/
	}
    },
    'variable': /\$+(?:[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,

    'keyword': [
	// Directives
	/-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\b/,
	// Functions
	{
	    pattern: /(\()(?:addsuffix|abspath|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:s|list)?)(?=[ \t])/,
	    lookbehind: true
	}
    ],
    'operator': /(?:::|[?:+!])?=|[|@]/,
    'punctuation': /[:;(){}]/
};
Prism.languages.markdown = Prism.languages.extend('markup', {});
Prism.languages.insertBefore('markdown', 'prolog', {
    'blockquote': {
	// > ...
	pattern: /^>(?:[\t ]*>)*/m,
	alias: 'punctuation'
    },
    'code': [
	{
	    // Prefixed by 4 spaces or 1 tab
	    pattern: /^(?: {4}|\t).+/m,
	    alias: 'keyword'
	},
	{
	    // `code`
	    // ``code``
	    pattern: /``.+?``|`[^`\n]+`/,
	    alias: 'keyword'
	}
    ],
    'title': [
	{
	    // title 1
	    // =======

	    // title 2
	    // -------
	    pattern: /\w+.*(?:\r?\n|\r)(?:==+|--+)/,
	    alias: 'important',
	    inside: {
		punctuation: /==+$|--+$/
	    }
	},
	{
	    // # title 1
	    // ###### title 6
	    pattern: /(^\s*)#+.+/m,
	    lookbehind: true,
	    alias: 'important',
	    inside: {
		punctuation: /^#+|#+$/
	    }
	}
    ],
    'hr': {
	// ***
	// ---
	// * * *
	// -----------
	pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
	lookbehind: true,
	alias: 'punctuation'
    },
    'list': {
	// * item
	// + item
	// - item
	// 1. item
	pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
	lookbehind: true,
	alias: 'punctuation'
    },
    'url-reference': {
	// [id]: http://example.com "Optional title"
	// [id]: http://example.com 'Optional title'
	// [id]: http://example.com (Optional title)
	// [id]: <http://example.com> "Optional title"
	pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
	inside: {
	    'variable': {
		pattern: /^(!?\[)[^\]]+/,
		lookbehind: true
	    },
	    'string': /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
	    'punctuation': /^[\[\]!:]|[<>]/
	},
	alias: 'url'
    },
    'bold': {
	// **strong**
	// __strong__

	// Allow only one line break
	pattern: /(^|[^\\])(\*\*|__)(?:(?:\r?\n|\r)(?!\r?\n|\r)|.)+?\2/,
	lookbehind: true,
	inside: {
	    'punctuation': /^\*\*|^__|\*\*$|__$/
	}
    },
    'italic': {
	// *em*
	// _em_

	// Allow only one line break
	pattern: /(^|[^\\])([*_])(?:(?:\r?\n|\r)(?!\r?\n|\r)|.)+?\2/,
	lookbehind: true,
	inside: {
	    'punctuation': /^[*_]|[*_]$/
	}
    },
    'url': {
	// [example](http://example.com "Optional title")
	// [example] [id]
	pattern: /!?\[[^\]]+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)| ?\[[^\]\n]*\])/,
	inside: {
	    'variable': {
		pattern: /(!?\[)[^\]]+(?=\]$)/,
		lookbehind: true
	    },
	    'string': {
		pattern: /"(?:\\.|[^"\\])*"(?=\)$)/
	    }
	}
    }
});

Prism.languages.markdown['bold'].inside['url'] = Prism.languages.markdown['url'];
Prism.languages.markdown['italic'].inside['url'] = Prism.languages.markdown['url'];
Prism.languages.markdown['bold'].inside['italic'] = Prism.languages.markdown['italic'];
Prism.languages.markdown['italic'].inside['bold'] = Prism.languages.markdown['bold'];
Prism.languages.nasm = {
    'comment': /;.*$/m,
    'string': /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
    'label': {
	pattern: /(^\s*)[A-Za-z._?$][\w.?$@~#]*:/m,
	lookbehind: true,
	alias: 'function'
    },
    'keyword': [
	    /\[?BITS (?:16|32|64)\]?/,
	{
	    pattern: /(^\s*)section\s*[a-zA-Z.]+:?/im,
	    lookbehind: true
	},
	    /(?:extern|global)[^;\r\n]*/i,
	    /(?:CPU|FLOAT|DEFAULT).*$/m
    ],
    'register': {
	pattern: /\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|sp|si|di)|[cdefgs]s)\b/i,
	alias: 'variable'
    },
    'number': /(?:\b|(?=\$))(?:0[hx][\da-f]*\.?[\da-f]+(?:p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|\d*\.?\d+(?:\.?e[+-]?\d+)?[dt]?)\b/i,
    'operator': /[\[\]*+\-\/%<>=&|$!]/
};

Prism.languages.nginx = Prism.languages.extend('clike', {
    'comment': {
	pattern: /(^|[^"{\\])#.*/,
	lookbehind: true
    },
    'keyword': /\b(?:CONTENT_|DOCUMENT_|GATEWAY_|HTTP_|HTTPS|if_not_empty|PATH_|QUERY_|REDIRECT_|REMOTE_|REQUEST_|SCGI|SCRIPT_|SERVER_|http|events|accept_mutex|accept_mutex_delay|access_log|add_after_body|add_before_body|add_header|addition_types|aio|alias|allow|ancient_browser|ancient_browser_value|auth|auth_basic|auth_basic_user_file|auth_http|auth_http_header|auth_http_timeout|autoindex|autoindex_exact_size|autoindex_localtime|break|charset|charset_map|charset_types|chunked_transfer_encoding|client_body_buffer_size|client_body_in_file_only|client_body_in_single_buffer|client_body_temp_path|client_body_timeout|client_header_buffer_size|client_header_timeout|client_max_body_size|connection_pool_size|create_full_put_path|daemon|dav_access|dav_methods|debug_connection|debug_points|default_type|deny|devpoll_changes|devpoll_events|directio|directio_alignment|disable_symlinks|empty_gif|env|epoll_events|error_log|error_page|expires|fastcgi_buffer_size|fastcgi_buffers|fastcgi_busy_buffers_size|fastcgi_cache|fastcgi_cache_bypass|fastcgi_cache_key|fastcgi_cache_lock|fastcgi_cache_lock_timeout|fastcgi_cache_methods|fastcgi_cache_min_uses|fastcgi_cache_path|fastcgi_cache_purge|fastcgi_cache_use_stale|fastcgi_cache_valid|fastcgi_connect_timeout|fastcgi_hide_header|fastcgi_ignore_client_abort|fastcgi_ignore_headers|fastcgi_index|fastcgi_intercept_errors|fastcgi_keep_conn|fastcgi_max_temp_file_size|fastcgi_next_upstream|fastcgi_no_cache|fastcgi_param|fastcgi_pass|fastcgi_pass_header|fastcgi_read_timeout|fastcgi_redirect_errors|fastcgi_send_timeout|fastcgi_split_path_info|fastcgi_store|fastcgi_store_access|fastcgi_temp_file_write_size|fastcgi_temp_path|flv|geo|geoip_city|geoip_country|google_perftools_profiles|gzip|gzip_buffers|gzip_comp_level|gzip_disable|gzip_http_version|gzip_min_length|gzip_proxied|gzip_static|gzip_types|gzip_vary|if|if_modified_since|ignore_invalid_headers|image_filter|image_filter_buffer|image_filter_jpeg_quality|image_filter_sharpen|image_filter_transparency|imap_capabilities|imap_client_buffer|include|index|internal|ip_hash|keepalive|keepalive_disable|keepalive_requests|keepalive_timeout|kqueue_changes|kqueue_events|large_client_header_buffers|limit_conn|limit_conn_log_level|limit_conn_zone|limit_except|limit_rate|limit_rate_after|limit_req|limit_req_log_level|limit_req_zone|limit_zone|lingering_close|lingering_time|lingering_timeout|listen|location|lock_file|log_format|log_format_combined|log_not_found|log_subrequest|map|map_hash_bucket_size|map_hash_max_size|master_process|max_ranges|memcached_buffer_size|memcached_connect_timeout|memcached_next_upstream|memcached_pass|memcached_read_timeout|memcached_send_timeout|merge_slashes|min_delete_depth|modern_browser|modern_browser_value|mp4|mp4_buffer_size|mp4_max_buffer_size|msie_padding|msie_refresh|multi_accept|open_file_cache|open_file_cache_errors|open_file_cache_min_uses|open_file_cache_valid|open_log_file_cache|optimize_server_names|override_charset|pcre_jit|perl|perl_modules|perl_require|perl_set|pid|pop3_auth|pop3_capabilities|port_in_redirect|post_action|postpone_output|protocol|proxy|proxy_buffer|proxy_buffer_size|proxy_buffering|proxy_buffers|proxy_busy_buffers_size|proxy_cache|proxy_cache_bypass|proxy_cache_key|proxy_cache_lock|proxy_cache_lock_timeout|proxy_cache_methods|proxy_cache_min_uses|proxy_cache_path|proxy_cache_use_stale|proxy_cache_valid|proxy_connect_timeout|proxy_cookie_domain|proxy_cookie_path|proxy_headers_hash_bucket_size|proxy_headers_hash_max_size|proxy_hide_header|proxy_http_version|proxy_ignore_client_abort|proxy_ignore_headers|proxy_intercept_errors|proxy_max_temp_file_size|proxy_method|proxy_next_upstream|proxy_no_cache|proxy_pass|proxy_pass_error_message|proxy_pass_header|proxy_pass_request_body|proxy_pass_request_headers|proxy_read_timeout|proxy_redirect|proxy_redirect_errors|proxy_send_lowat|proxy_send_timeout|proxy_set_body|proxy_set_header|proxy_ssl_session_reuse|proxy_store|proxy_store_access|proxy_temp_file_write_size|proxy_temp_path|proxy_timeout|proxy_upstream_fail_timeout|proxy_upstream_max_fails|random_index|read_ahead|real_ip_header|recursive_error_pages|request_pool_size|reset_timedout_connection|resolver|resolver_timeout|return|rewrite|root|rtsig_overflow_events|rtsig_overflow_test|rtsig_overflow_threshold|rtsig_signo|satisfy|satisfy_any|secure_link_secret|send_lowat|send_timeout|sendfile|sendfile_max_chunk|server|server_name|server_name_in_redirect|server_names_hash_bucket_size|server_names_hash_max_size|server_tokens|set|set_real_ip_from|smtp_auth|smtp_capabilities|so_keepalive|source_charset|split_clients|ssi|ssi_silent_errors|ssi_types|ssi_value_length|ssl|ssl_certificate|ssl_certificate_key|ssl_ciphers|ssl_client_certificate|ssl_crl|ssl_dhparam|ssl_engine|ssl_prefer_server_ciphers|ssl_protocols|ssl_session_cache|ssl_session_timeout|ssl_verify_client|ssl_verify_depth|starttls|stub_status|sub_filter|sub_filter_once|sub_filter_types|tcp_nodelay|tcp_nopush|timeout|timer_resolution|try_files|types|types_hash_bucket_size|types_hash_max_size|underscores_in_headers|uninitialized_variable_warn|upstream|use|user|userid|userid_domain|userid_expires|userid_name|userid_p3p|userid_path|userid_service|valid_referers|variables_hash_bucket_size|variables_hash_max_size|worker_connections|worker_cpu_affinity|worker_priority|worker_processes|worker_rlimit_core|worker_rlimit_nofile|worker_rlimit_sigpending|working_directory|xclient|xml_entities|xslt_entities|xslt_stylesheet|xslt_types)\b/i
});

Prism.languages.insertBefore('nginx', 'keyword', {
    'variable': /\$[a-z_]+/i
});
Prism.languages.objectivec = Prism.languages.extend('c', {
    'keyword': /\b(?:asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|in|self|super)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
    'string': /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|@"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    'operator': /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
});

Prism.languages.sql= {
    'comment': {
	pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
	lookbehind: true
    },
    'string' : {
	pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\])*\2/,
	greedy: true,
	lookbehind: true
    },
    'variable': /@[\w.$]+|@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
    'function': /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i, // Should we highlight user defined functions too?
    'keyword': /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:_INSERT|COL)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEATABLE|REPLACE|REPLICATION|REQUIRE|RESTORE|RESTRICT|RETURNS?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
    'boolean': /\b(?:TRUE|FALSE|NULL)\b/i,
    'number': /\b0x[\da-f]+\b|\b\d+\.?\d*|\B\.\d+\b/i,
    'operator': /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|IN|LIKE|NOT|OR|IS|DIV|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
    'punctuation': /[;[\]()`,.]/
};
Prism.languages.powershell = {
    'comment': [
	{
	    pattern: /(^|[^`])<#[\s\S]*?#>/,
	    lookbehind: true
	},
	{
	    pattern: /(^|[^`])#.*/,
	    lookbehind: true
	}
    ],
    'string': [
	{
	    pattern: /"(?:`[\s\S]|[^`"])*"/,
	    greedy: true,
	    inside: {
		'function': {
		    pattern: /[^`]\$\(.*?\)/,
		    // Populated at end of file
		    inside: {}
		}
	    }
	},
	{
	    pattern: /'(?:[^']|'')*'/,
	    greedy: true
	}
    ],
    // Matches name spaces as well as casts, attribute decorators. Force starting with letter to avoid matching array indices
    // Supports two levels of nested brackets (e.g. `[OutputType([System.Collections.Generic.List[int]])]`)
    'namespace': /\[[a-z](?:\[(?:\[[^\]]*]|[^\[\]])*]|[^\[\]])*]/i,
    'boolean': /\$(?:true|false)\b/i,
    'variable': /\$\w+\b/i,
    // Cmdlets and aliases. Aliases should come last, otherwise "write" gets preferred over "write-host" for example
    // Get-Command | ?{ $_.ModuleName -match "Microsoft.PowerShell.(Util|Core|Management)" }
    // Get-Alias | ?{ $_.ReferencedCommand.Module.Name -match "Microsoft.PowerShell.(Util|Core|Management)" }
    'function': [
	    /\b(?:Add-(?:Computer|Content|History|Member|PSSnapin|Type)|Checkpoint-Computer|Clear-(?:Content|EventLog|History|Item|ItemProperty|Variable)|Compare-Object|Complete-Transaction|Connect-PSSession|ConvertFrom-(?:Csv|Json|StringData)|Convert-Path|ConvertTo-(?:Csv|Html|Json|Xml)|Copy-(?:Item|ItemProperty)|Debug-Process|Disable-(?:ComputerRestore|PSBreakpoint|PSRemoting|PSSessionConfiguration)|Disconnect-PSSession|Enable-(?:ComputerRestore|PSBreakpoint|PSRemoting|PSSessionConfiguration)|Enter-PSSession|Exit-PSSession|Export-(?:Alias|Clixml|Console|Csv|FormatData|ModuleMember|PSSession)|ForEach-Object|Format-(?:Custom|List|Table|Wide)|Get-(?:Alias|ChildItem|Command|ComputerRestorePoint|Content|ControlPanelItem|Culture|Date|Event|EventLog|EventSubscriber|FormatData|Help|History|Host|HotFix|Item|ItemProperty|Job|Location|Member|Module|Process|PSBreakpoint|PSCallStack|PSDrive|PSProvider|PSSession|PSSessionConfiguration|PSSnapin|Random|Service|TraceSource|Transaction|TypeData|UICulture|Unique|Variable|WmiObject)|Group-Object|Import-(?:Alias|Clixml|Csv|LocalizedData|Module|PSSession)|Invoke-(?:Command|Expression|History|Item|RestMethod|WebRequest|WmiMethod)|Join-Path|Limit-EventLog|Measure-(?:Command|Object)|Move-(?:Item|ItemProperty)|New-(?:Alias|Event|EventLog|Item|ItemProperty|Module|ModuleManifest|Object|PSDrive|PSSession|PSSessionConfigurationFile|PSSessionOption|PSTransportOption|Service|TimeSpan|Variable|WebServiceProxy)|Out-(?:Default|File|GridView|Host|Null|Printer|String)|Pop-Location|Push-Location|Read-Host|Receive-(?:Job|PSSession)|Register-(?:EngineEvent|ObjectEvent|PSSessionConfiguration|WmiEvent)|Remove-(?:Computer|Event|EventLog|Item|ItemProperty|Job|Module|PSBreakpoint|PSDrive|PSSession|PSSnapin|TypeData|Variable|WmiObject)|Rename-(?:Computer|Item|ItemProperty)|Reset-ComputerMachinePassword|Resolve-Path|Restart-(?:Computer|Service)|Restore-Computer|Resume-(?:Job|Service)|Save-Help|Select-(?:Object|String|Xml)|Send-MailMessage|Set-(?:Alias|Content|Date|Item|ItemProperty|Location|PSBreakpoint|PSDebug|PSSessionConfiguration|Service|StrictMode|TraceSource|Variable|WmiInstance)|Show-(?:Command|ControlPanelItem|EventLog)|Sort-Object|Split-Path|Start-(?:Job|Process|Service|Sleep|Transaction)|Stop-(?:Computer|Job|Process|Service)|Suspend-(?:Job|Service)|Tee-Object|Test-(?:ComputerSecureChannel|Connection|ModuleManifest|Path|PSSessionConfigurationFile)|Trace-Command|Unblock-File|Undo-Transaction|Unregister-(?:Event|PSSessionConfiguration)|Update-(?:FormatData|Help|List|TypeData)|Use-Transaction|Wait-(?:Event|Job|Process)|Where-Object|Write-(?:Debug|Error|EventLog|Host|Output|Progress|Verbose|Warning))\b/i,
	    /\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i
    ],
    // per http://technet.microsoft.com/en-us/library/hh847744.aspx
    'keyword': /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
    'operator': {
	pattern: /(\W?)(?:!|-(eq|ne|gt|ge|lt|le|sh[lr]|not|b?(?:and|x?or)|(?:Not)?(?:Like|Match|Contains|In)|Replace|Join|is(?:Not)?|as)\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
	lookbehind: true
    },
    'punctuation': /[|{}[\];(),.]/
};

// Variable interpolation inside strings, and nested expressions
Prism.languages.powershell.string[0].inside.boolean = Prism.languages.powershell.boolean;
Prism.languages.powershell.string[0].inside.variable = Prism.languages.powershell.variable;
Prism.languages.powershell.string[0].inside.function.inside = Prism.languages.powershell;

Prism.languages.protobuf = Prism.languages.extend('clike', {
    keyword: /\b(?:package|import|message|enum)\b/,
    builtin: /\b(?:required|repeated|optional|reserved)\b/,
    primitive: {
	pattern: /\b(?:double|float|int32|int64|uint32|uint64|sint32|sint64|fixed32|fixed64|sfixed32|sfixed64|bool|string|bytes)\b/,
	alias: 'symbol'
    }
});

Prism.languages.python = {
    'comment': {
	pattern: /(^|[^\\])#.*/,
	lookbehind: true
    },
    'triple-quoted-string': {
	pattern: /("""|''')[\s\S]+?\1/,
	greedy: true,
	alias: 'string'
    },
    'string': {
	pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
	greedy: true
    },
    'function': {
	pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
	lookbehind: true
    },
    'class-name': {
	pattern: /(\bclass\s+)\w+/i,
	lookbehind: true
    },
    'keyword': /\b(?:as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|nonlocal|pass|print|raise|return|try|while|with|yield)\b/,
    'builtin':/\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
    'boolean': /\b(?:True|False|None)\b/,
    'number': /(?:\b(?=\d)|\B(?=\.))(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*\.?\d*|\.\d+)(?:e[+-]?\d+)?j?\b/i,
    'operator': /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]|\b(?:or|and|not)\b/,
    'punctuation': /[{}[\];(),.:]/
};

Prism.languages.r = {
    'comment': /#.*/,
    'string': {
	pattern: /(['"])(?:\\.|(?!\1)[^\\\r\n])*\1/,
	greedy: true
    },
    'percent-operator': {
	// Includes user-defined operators
	// and %%, %*%, %/%, %in%, %o%, %x%
	pattern: /%[^%\s]*%/,
	alias: 'operator'
    },
    'boolean': /\b(?:TRUE|FALSE)\b/,
    'ellipsis': /\.\.(?:\.|\d+)/,
    'number': [
	    /\b(?:NaN|Inf)\b/,
	    /(?:\b0x[\dA-Fa-f]+(?:\.\d*)?|\b\d+\.?\d*|\B\.\d+)(?:[EePp][+-]?\d+)?[iL]?/
    ],
    'keyword': /\b(?:if|else|repeat|while|function|for|in|next|break|NULL|NA|NA_integer_|NA_real_|NA_complex_|NA_character_)\b/,
    'operator': /->?>?|<(?:=|<?-)?|[>=!]=?|::?|&&?|\|\|?|[+*\/^$@~]/,
    'punctuation': /[(){}\[\],;]/
};
Prism.languages.typescript = Prism.languages.extend('javascript', {
    // From JavaScript Prism keyword list and TypeScript language spec: https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#221-reserved-words
    'keyword': /\b(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield|module|declare|constructor|namespace|abstract|require|type)\b/,
    'builtin': /\b(?:string|Function|any|number|boolean|Array|symbol|console)\b/,
});

Prism.languages.ts = Prism.languages.typescript;
Prism.languages.scala = Prism.languages.extend('java', {
    'keyword': /<-|=>|\b(?:abstract|case|catch|class|def|do|else|extends|final|finally|for|forSome|if|implicit|import|lazy|match|new|null|object|override|package|private|protected|return|sealed|self|super|this|throw|trait|try|type|val|var|while|with|yield)\b/,
    'string': [
	{
	    pattern: /"""[\s\S]*?"""/,
	    greedy: true
	},
	{
	    pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
	    greedy: true
	}
    ],
    'builtin': /\b(?:String|Int|Long|Short|Byte|Boolean|Double|Float|Char|Any|AnyRef|AnyVal|Unit|Nothing)\b/,
    'number': /\b0x[\da-f]*\.?[\da-f]+|(?:\b\d+\.?\d*|\B\.\d+)(?:e\d+)?[dfl]?/i,
    'symbol': /'[^\d\s\\]\w*/
});
delete Prism.languages.scala['class-name'];
delete Prism.languages.scala['function'];

Prism.languages.scheme = {
    'comment' : /;.*/,
    'string' :  {
	pattern: /"(?:[^"\\\r\n]|\\.)*"|'[^('\s]*/,
	greedy: true
    },
    'keyword' : {
	pattern : /(\()(?:define(?:-syntax|-library|-values)?|(?:case-)?lambda|let(?:\*|rec)?(?:-values)?|else|if|cond|begin|delay(?:-force)?|parameterize|guard|set!|(?:quasi-)?quote|syntax-rules)/,
	lookbehind : true
    },
    'builtin' : {
	pattern :  /(\()(?:(?:cons|car|cdr|list|call-with-current-continuation|call\/cc|append|abs|apply|eval)\b|null\?|pair\?|boolean\?|eof-object\?|char\?|procedure\?|number\?|port\?|string\?|vector\?|symbol\?|bytevector\?)/,
	lookbehind : true
    },
    'number' : {
	pattern: /(\s|[()])[-+]?\d*\.?\d+(?:\s*[-+]\s*\d*\.?\d+i)?\b/,
	lookbehind: true
    },
    'boolean' : /#[tf]/,
    'operator': {
	pattern: /(\()(?:[-+*%\/]|[<>]=?|=>?)/,
	lookbehind: true
    },
    'function' : {
	pattern : /(\()[^\s()]*(?=\s)/,
	lookbehind : true
    },
    'punctuation' : /[()]/
};
// issues: nested multiline comments
Prism.languages.swift = Prism.languages.extend('clike', {
    'string': {
	pattern: /("|')(\\(?:\((?:[^()]|\([^)]+\))+\)|\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
	greedy: true,
	inside: {
	    'interpolation': {
		pattern: /\\\((?:[^()]|\([^)]+\))+\)/,
		inside: {
		    delimiter: {
			pattern: /^\\\(|\)$/,
			alias: 'variable'
		    }
		    // See rest below
		}
	    }
	}
    },
    'keyword': /\b(?:as|associativity|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic(?:Type)?|else|enum|extension|fallthrough|final|for|func|get|guard|if|import|in|infix|init|inout|internal|is|lazy|left|let|mutating|new|none|nonmutating|operator|optional|override|postfix|precedence|prefix|private|Protocol|public|repeat|required|rethrows|return|right|safe|self|Self|set|static|struct|subscript|super|switch|throws?|try|Type|typealias|unowned|unsafe|var|weak|where|while|willSet|__(?:COLUMN__|FILE__|FUNCTION__|LINE__))\b/,
    'number': /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
    'constant': /\b(?:nil|[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
    'atrule': /@\b(?:IB(?:Outlet|Designable|Action|Inspectable)|class_protocol|exported|noreturn|NS(?:Copying|Managed)|objc|UIApplicationMain|auto_closure)\b/,
    'builtin': /\b(?:[A-Z]\S+|abs|advance|alignof(?:Value)?|assert|contains|count(?:Elements)?|debugPrint(?:ln)?|distance|drop(?:First|Last)|dump|enumerate|equal|filter|find|first|getVaList|indices|isEmpty|join|last|lexicographicalCompare|map|max(?:Element)?|min(?:Element)?|numericCast|overlaps|partition|print(?:ln)?|reduce|reflect|reverse|sizeof(?:Value)?|sort(?:ed)?|split|startsWith|stride(?:of(?:Value)?)?|suffix|swap|toDebugString|toString|transcode|underestimateCount|unsafeBitCast|with(?:ExtendedLifetime|Unsafe(?:MutablePointers?|Pointers?)|VaList))\b/
});
Prism.languages.swift['string'].inside['interpolation'].inside.rest = Prism.languages.swift;
Prism.languages.yaml = {
    'scalar': {
	pattern: /([\-:]\s*(?:![^\s]+)?[ \t]*[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)[^\r\n]+(?:\2[^\r\n]+)*)/,
	lookbehind: true,
	alias: 'string'
    },
    'comment': /#.*/,
    'key': {
	pattern: /(\s*(?:^|[:\-,[{\r\n?])[ \t]*(?:![^\s]+)?[ \t]*)[^\r\n{[\]},#\s]+?(?=\s*:\s)/,
	lookbehind: true,
	alias: 'atrule'
    },
    'directive': {
	pattern: /(^[ \t]*)%.+/m,
	lookbehind: true,
	alias: 'important'
    },
    'datetime': {
	pattern: /([:\-,[{]\s*(?:![^\s]+)?[ \t]*)(?:\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?)?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?)(?=[ \t]*(?:$|,|]|}))/m,
	lookbehind: true,
	alias: 'number'
    },
    'boolean': {
	pattern: /([:\-,[{]\s*(?:![^\s]+)?[ \t]*)(?:true|false)[ \t]*(?=$|,|]|})/im,
	lookbehind: true,
	alias: 'important'
    },
    'null': {
	pattern: /([:\-,[{]\s*(?:![^\s]+)?[ \t]*)(?:null|~)[ \t]*(?=$|,|]|})/im,
	lookbehind: true,
	alias: 'important'
    },
    'string': {
	pattern: /([:\-,[{]\s*(?:![^\s]+)?[ \t]*)("|')(?:(?!\2)[^\\\r\n]|\\.)*\2(?=[ \t]*(?:$|,|]|}))/m,
	lookbehind: true,
	greedy: true
    },
    'number': {
	pattern: /([:\-,[{]\s*(?:![^\s]+)?[ \t]*)[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+\.?\d*|\.?\d+)(?:e[+-]?\d+)?|\.inf|\.nan)[ \t]*(?=$|,|]|})/im,
	lookbehind: true
    },
    'tag': /![^\s]+/,
    'important': /[&*][\w]+/,
    'punctuation': /---|[:[\]{}\-,|>?]|\.\.\./
};

(function() {

if (typeof self === 'undefined' || !self.Prism || !self.document) {
	return;
}

Prism.hooks.add('complete', function (env) {
	if (!env.code) {
		return;
	}

	// Works only for <code> wrapped inside <pre> (not inline).
	var pre = env.element.parentNode;
	var clsReg = /\s*\bcommand-line\b\s*/;
	if (
		!pre || !/pre/i.test(pre.nodeName) ||
			// Abort only if neither the <pre> nor the <code> have the class
		(!clsReg.test(pre.className) && !clsReg.test(env.element.className))
	) {
		return;
	}

	if (env.element.querySelector('.command-line-prompt')) {
		// Abort if prompt already exists.
		return;
	}

	if (clsReg.test(env.element.className)) {
		// Remove the class "command-line" from the <code>
		env.element.className = env.element.className.replace(clsReg, '');
	}
	if (!clsReg.test(pre.className)) {
		// Add the class "command-line" to the <pre>
		pre.className += ' command-line';
	}

	var getAttribute = function(key, defaultValue) {
		return (pre.getAttribute(key) || defaultValue).replace(/"/g, '&quot');
	};

	// Create the "rows" that will become the command-line prompts. -- cwells
	var content = env.code.split('\n');
	var lines = new Array(1 + content.length);
	var promptText = getAttribute('data-prompt', '');
	if (promptText !== '') {
		lines = lines.join('<span data-prompt="' + promptText + '"></span>');
	} else {
		var user = getAttribute('data-user', 'user');
		var host = getAttribute('data-host', 'localhost');
		lines = lines.join('<span data-user="' + user + '" data-host="' + host + '"></span>');
	}

	// Create the wrapper element. -- cwells
	var prompt = document.createElement('span');
	prompt.className = 'command-line-prompt';
	prompt.innerHTML = lines;

	var filterContent = getAttribute('data-filter', '');
	if (filterContent.length > 0) {
		for (var i = 0; i < content.length; i++) {
			var line = content[i];
			if (line.slice(0, promptText.length) == promptText) {
				// We have a command -- strip off the prompt from the source text and wrap in <span>
				content[i] = '<span class="command-line-command">' + line.slice(promptText.length + 1) + 
					'</span>';
			}
			else {
				// We have output -- strip off the prompt tags for the line
				var node = prompt.children[i];
				node.removeAttribute('data-user');
				node.removeAttribute('data-host');
				node.removeAttribute('data-prompt');
			}
		}
		env.element.innerHTML = content.join('\n');
	}

	// Mark the output lines so they can be styled differently (no prompt). -- cwells
	var outputSections = pre.getAttribute('data-output') || '';
	outputSections = outputSections.split(',');
	for (var i = 0; i < outputSections.length; i++) {
		var outputRange = outputSections[i].split('-');
		var outputStart = parseInt(outputRange[0]);
		var outputEnd = outputStart; // Default: end at the first line when it's not an actual range. -- cwells
		if (outputRange.length === 2) {
			outputEnd = parseInt(outputRange[1]);
		}

		if (!isNaN(outputStart) && !isNaN(outputEnd)) {
			for (var j = outputStart; j <= outputEnd && j <= prompt.children.length; j++) {
				var node = prompt.children[j - 1];
				node.removeAttribute('data-user');
				node.removeAttribute('data-host');
				node.removeAttribute('data-prompt');
			}
		}
	}

	env.element.innerHTML = prompt.outerHTML + env.element.innerHTML;
});

}());

(function () {

    if (typeof self === 'undefined' || !self.Prism || !self.document || !document.createRange) {
	return;
    }

    Prism.plugins.KeepMarkup = true;

    Prism.hooks.add('before-highlight', function (env) {
	if (!env.element.children.length) {
	    return;
	}

	var pos = 0;
	var data = [];
	var f = function (elt, baseNode) {
	    var o = {};
	    if (!baseNode) {
		// Clone the original tag to keep all attributes
		o.clone = elt.cloneNode(false);
		o.posOpen = pos;
		data.push(o);
	    }
	    for (var i = 0, l = elt.childNodes.length; i < l; i++) {
		var child = elt.childNodes[i];
		if (child.nodeType === 1) { // element
		    f(child);
		} else if(child.nodeType === 3) { // text
		    pos += child.data.length;
		}
	    }
	    if (!baseNode) {
		o.posClose = pos;
	    }
	};
	f(env.element, true);

	if (data && data.length) {
	    // data is an array of all existing tags
	    env.keepMarkup = data;
	}
    });

    Prism.hooks.add('after-highlight', function (env) {
	if(env.keepMarkup && env.keepMarkup.length) {

	    var walk = function (elt, nodeState) {
		for (var i = 0, l = elt.childNodes.length; i < l; i++) {

		    var child = elt.childNodes[i];

		    if (child.nodeType === 1) { // element
			if (!walk(child, nodeState)) {
			    return false;
			}

		    } else if (child.nodeType === 3) { // text
			if(!nodeState.nodeStart && nodeState.pos + child.data.length > nodeState.node.posOpen) {
			    // We found the start position
			    nodeState.nodeStart = child;
			    nodeState.nodeStartPos = nodeState.node.posOpen - nodeState.pos;
			}
			if(nodeState.nodeStart && nodeState.pos + child.data.length >= nodeState.node.posClose) {
			    // We found the end position
			    nodeState.nodeEnd = child;
			    nodeState.nodeEndPos = nodeState.node.posClose - nodeState.pos;
			}

			nodeState.pos += child.data.length;
		    }

		    if (nodeState.nodeStart && nodeState.nodeEnd) {
			// Select the range and wrap it with the clone
			var range = document.createRange();
			range.setStart(nodeState.nodeStart, nodeState.nodeStartPos);
			range.setEnd(nodeState.nodeEnd, nodeState.nodeEndPos);
			nodeState.node.clone.appendChild(range.extractContents());
			range.insertNode(nodeState.node.clone);
			range.detach();

			// Process is over
			return false;
		    }
		}
		return true;
	    };

	    // For each tag, we walk the DOM to reinsert it
	    env.keepMarkup.forEach(function (node) {
		walk(env.element, {
		    node: node,
		    pos: 0
		});
	    });
	    // Store new highlightedCode for later hooks calls
	    env.highlightedCode = env.element.innerHTML;
	}
    });
}());
